---
layout: post
title: "Flying With the Wind"
date: 2024-10-12
features: [chart, highlight, mathjax]
---

On a romantic date 12,000 kilometers from home, I sat in a hot air balloon wondering how the pilot managed to steer the aircraft. After all, it seemed like the ballon only had controls to go up and down, yet the flight path seemed so intentional. I wanted to understand the dynamics of these balloons, and build a virtual controller capable of maneuvering them.

## Ballon Dynamics

The dynamics of hot air balloons has been well-studied. We use the derivation from Badgwell[^badgwell] as the reference. Bagewell modeled the vertical dynamics of an AX7-77[^ax7-77]. The balloon that I rode in was a larger and heavier one, but we will build our simulation and controllers for an AX7-77 because it is useful to have a reference implementation to compare against.

We will summarize the dynamics at a high level and extend it to incorporate horizontal motion. Define the following terms. Most of the derivation is omitted for simplicity.

- Let $$\textbf{p} = \left(p_\textrm{x}, p_\textrm{y}, p_\textrm{z}\right)$$ be the position of the balloon.
- Let $$\textbf{w} = \left(w_\textrm{x}, w_\textrm{y}, w_\textrm{z}\right)$$ be the wind velocity at the current position of the balloon.
- Let $$m_\textrm{t}$$ be the total mass of the balloon, including the air in the envelope.
- Let $$m_\textrm{p}$$ be the payload mass of the balloon, excluding the air in the envelope.
- Let $$k_\textrm{d}$$ be the proportional constant of the drag force on the balloon.
- Let $$F_\textrm{l}$$ be the lift force generated by the hotter air in the envelope.
- Let $$g$$ be the acceleration due to gravity.

The acceleration in each component is given by the following equation. We assume the drag constant is the same in all directions, which treats the hot air ballon as a sphere. This is not a perfectly accurate model, but should be good enough given that the envelope represents most of the ballon's surface area and is approximately spherical.

$$\frac{d^2\textbf{p}}{dt^2} = \frac{1}{m_\text{t}} \left[ k_\text{d} \left| \textbf{w} - \frac{d\textbf{p}}{dt} \right| \left[ \textbf{w} - \frac{d\textbf{p}}{dt} \right] + \begin{pmatrix} 0 \\ 0 \\ F_\text{l} - m_\text{p} g \end{pmatrix} \right] $$

The drag force is a function of the relative wind velocity. This is a generalization of Badgwell's model where the wind velocity is zero in everywhere. The lift force is a function of the height of the ballon and the temperature of air in the envelope. The height is necessary to determine the outside air temperature, which Badgwell models as linearly decreasing with height.

The air temperature inside the envelope is controlled by the fuel valve and the vent valve. Increasing the fuel valve heats up the air in the envelope, while increasing the vent valve lets hot air out from the top of the envelope, effectively cooling the air inside. There is also heat dissipation as a result of the cooler outside air. Therefore, the derivative of envelope air temperature is a function of the fuel and vent valve positions along with the temperatures of the inside and outside air.

## Modelling Wind

To move horizontally, a hot air balloon relies on varying wind velocities at different altitudes. A uniform wind field is not very interesting to simulate since the ballon will always move in the same direction on the horizontal plane. However, a detailed model of localized wind patterns is beyond the scope of this post. Instead, we rely on a simplified wind model based on random control points.

Define the wind field as a function that takes in the position of the balloon and returns the wind velocity at that position. Given the boundaries of the simulation, we place evenly spaced control points. For each control point, we generate a random wind velocity within a specified magnitude. The output wind velocity at any point is determined through trilinear interpolation in the regular grid.

```python
control_points = (
    np.linspace(-1000, 1000, 20),
    np.linspace(-1000, 1000, 20),
    np.linspace(0, 2000, 20),
)
control_vectors = (
    np.random.uniform(-5, 5, size=(20, 20, 20)),
    np.random.uniform(-5, 5, size=(20, 20, 20)),
    np.random.uniform(-1, 1, size=(20, 20, 20)),
)
wind_vector = (
    internp(control_points, control_vectors[i], position)
    for i in range(3)
)
```

The above snippet shows an example of evaluating a random wind field defined in a 2 km × 2 km × 2 km grid. The horizontal wind magnitude is up to 5 m/s, and the vertical wind magnitude is up to 1 m/s. We show SciPy's `internp`[^interpn] function here, but the actual implementation uses a faster `interp3d`[^interp3d] library since the wind field is evaluated in the hot path of the simulation.

TODO: Show a 2D wind field.

## Simulation Setup

## Moving Vertically

## Moving Horizontally

## Extensions

## References

[^badgwell]: Badgwell, Thomas (2017). [Dynamic Simulation of a Hot Air Balloon](https://github.com/APMonitor/applications/blob/master/ASEE_Summer_School_2017/Demo2_Hot_Air_Balloon/HAB%20Simulation.pdf).
[^ax7-77]: Head Balloons (2024). [AX7-77](https://www.headballoons.com/ax777.htm).
[^interpn]: The SciPy community (2024). [interpn - SciPy Manual](https://docs.scipy.org/doc/scipy/reference/generated/scipy.interpolate.interpn.html).
[^interp3d]: Glaser, Jens (2019). [A fast alternative for scipy.interpolate.RegularGridInterpolator in d=3](https://github.com/jglaser/interp3d).

{% raw %}
<div class="chart" id="chart-test" style="aspect-ratio: 1; max-width: 600px"></div>
<script src="chart-test.js" type="module"></script>
{% endraw %}